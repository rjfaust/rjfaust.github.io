tracerWrap="variables = None\ntracked = []\n\ndef initialize_tracer(fname):\n    t = Tracer()\n\n    lines = t.readFile(fname)\n    return t, lines\n\n\ndef addObject(tracer, name, isVar, lineno, offset, containingFuncStr,custom):\n    obj = TrackObject(name, isVar, lineno, offset, containingFuncStr,custom)\n    tracked.append(obj)\n    tracer.add_tracked(obj)\n\n\ndef findContainingFuncs(lineno,functions):\n    funcs = list(functions.keys())\n    ind = 0\n    maxInd = len(funcs)\n    currChoice = \"\"\n    for i in range(maxInd):\n        if (functions[funcs[i]][\"start\"] < lineno and functions[funcs[i]][\"end\"] > lineno):\n            if currChoice == \"\":\n                currChoice = funcs[i]\n            else:\n                if functions[funcs[currChoice]][\"start\"] < functions[funcs[i]][\"start\"] and functions[funcs[currChoice]][\"end\"] >= functions[funcs[i]][\"end\"]:\n                        currChoice = currChoice+\"_\"+funcs[i]\n\n    return currChoice\n\n\ndef addExclusion(tracer, name, isFunc, lineno, containingFuncStr):\n    obj = ExclusionObject(name, isFunc, lineno, containingFuncStr)\n    tracer.add_exclusion(obj)\n\n\ndef runTrace(fname, variables, expressions, funcExclusions, libExclusions, overview, outputFileName=None):\n    import os\n    print(\"CWD: \", os.getcwd())\n\n    f = open(fname, \"r\")\n    text = f.read()\n    f.close()\n    head = sv_generateHead(text)\n\n    visitor = CallExtentVisitor(text.split(\"\\n\"))\n    visitor.visit(head)\n    functions = visitor.functions\n    loops = visitor.loops\n\n    visitor = DependencyVisitor()\n    visitor.visit(head)\n    dependencies = visitor.contributors\n    # print(dependencies)\n\n    # visitor = staticVisitor.JoinVisitor()\n    # visitor.visit(head)\n\n\n    t, lines = initialize_tracer(\"./\" + fname)\n\n    for v in variables:\n        funcStr = findContainingFuncs(v[\"line\"], functions)\n\n        addObject(t, v[\"name\"], True, v[\"line\"], v[\"offset\"], funcStr, v[\"custom_exprs\"])\n\n    for e in expressions:\n        funcStr = findContainingFuncs(e[\"line\"], functions)\n\n        addObject(t, e[\"expr\"], False, e[\"line\"], e[\"offset\"], funcStr, e[\"custom_exprs\"])\n\n    for f in funcExclusions:\n        if f[\"name\"] in functions:\n            contStr = findContainingFuncs(functions[f[\"name\"]][\"start\"]+1, functions)\n\n            if contStr != \"\":\n                contStr = contStr[:contStr.find(f[\"name\"])]\n        else:\n            contStr = \"\"\n        addExclusion(t, f[\"name\"], True, f[\"line\"], contStr)\n\n\n\n    for f in libExclusions:\n        if f[\"name\"] in functions:\n            contStr = findContainingFuncs(functions[f[\"name\"]][\"start\"]+1, functions)\n            contStr = contStr[:contStr.find(f[\"name\"])]\n        else:\n            contStr = \"\"\n        addExclusion(t, f[\"name\"], False, f[\"line\"], contStr)\n\n    t.readFile(fname)\n    t.runTrace(outputFileName)\n    output = t.output\n    lines = output.split(\"\\n\")\n    output = \"\"\n    for line in lines:\n        output += line+\"\\\\n\"\n\n    return outputFileName + \".trace\", functions, dependencies, output, loops\n"