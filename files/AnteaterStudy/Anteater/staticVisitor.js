tracerStaticVis="import ast\n\ndef createInfo(lineno):\n    info={\"start\":lineno,\n          \"end\":None}\n    return  info\n\ndef sv_generateHead(source):\n    return ast.parse(source)\n\n\ndef build_code_line(lines):\n\n    ind = 0\n    curLine = lines[ind].strip()\n    whitespace = lines[ind][:lines[ind].find(lines[ind].strip())]\n    blockStack = []\n    lineInd = 0\n    inString = False\n    curQuote = None\n    lineText = whitespace + lines[ind].strip()\n    # print(curLine)\n    while (lineInd < len(curLine) or len(blockStack) > 0):\n\n        if curLine[lineInd] == \"\\\"\" or curLine[lineInd] == \"'\":\n            if inString and curLine[lineInd] == curQuote:\n                curQuote = None\n                inString = False\n            elif not inString:\n                inString = True\n                curQuote = curLine[lineInd]\n\n        if not inString:\n            if curLine[lineInd] == \"[\" or curLine[lineInd] == \"(\" or curLine[lineInd] == \"{\":\n                blockStack.append(curLine[lineInd])\n            elif curLine[lineInd] == \"]\" or curLine[lineInd] == \")\" or curLine[lineInd] == \"}\":\n                blockStack.pop()\n        lineInd += 1\n\n        if lineInd == len(curLine) and len(blockStack) > 0:\n            ind += 1\n            whitespace = lines[ind][:lines[ind].find(lines[ind].strip())]\n            curLine = lines[ind].strip()\n            lineText += \"\\n\"+whitespace + curLine\n            lineInd = 0\n\n    return lineText\n\nclass CallExtentVisitor(ast.NodeVisitor):\n    def __init__(self,source):\n        self.functions = {}\n        self.loops = {}\n        self.source = source\n\n    def visit(self,node):\n        nodeType = type(node)\n        if nodeType is ast.While:\n            info = createInfo(node.lineno)\n\n            endNode = self.get_last_child(node.body)\n\n            info[\"end\"] = endNode.lineno\n\n            self.loops.update({\"while-\" + str(node.lineno): info})\n        elif nodeType is ast.For:\n            info = createInfo(node.lineno)\n            endNode = self.get_last_child(node.body)\n\n            info[\"end\"] = endNode.lineno\n\n            self.loops.update({\"for-\" + str(node.lineno): info})\n        elif nodeType is ast.FunctionDef:\n            info = createInfo(node.lineno)\n            endNode = self.get_last_child(node.body)\n\n            info[\"end\"] = endNode.lineno\n\n            self.functions.update({node.name: info})\n        elif nodeType is ast.Assign and type(node.value)is ast.ListComp:\n            info = createInfo(node.value.lineno)\n            # endNode = self.get_last_child(node.body)\n\n            lines = build_code_line(self.source[node.value.lineno - 1:])\n            lines = lines.split(\"\\n\")\n\n            info[\"end\"] = node.value.lineno + len(lines)-1\n\n            self.loops.update({\"for-\" + str(node.lineno): info})\n\n        if hasattr(node,\"body\"):\n            for n in node.body:\n                self.visit(n)\n\n\n\n    def get_last_child(self,body):\n        lastNode = body[-1]\n        while hasattr(lastNode,\"body\"):\n            if type(lastNode) is ast.If and hasattr(lastNode,\"orelse\") and len(lastNode.orelse) >0:\n                lastNode = lastNode.orelse[-1]\n            else:\n                lastNode = lastNode.body[-1]\n\n        return lastNode\n\n\n\n    def visit_While(self,node):\n        for n in node.body:\n            self.visit(n)\n            print(ast.dump(n))\n\n        info = createInfo(node.lineno)\n\n        endNode = self.get_last_child(node.body)\n\n        info[\"end\"] =endNode.lineno\n\n        self.loops.update({\"while-\"+str(node.lineno):info})\n\n    def visit_For(self, node):\n        for n in node.body:\n            self.visit(n)\n            print(ast.dump(n))\n\n        info = createInfo(node.lineno)\n        endNode = self.get_last_child(node.body)\n\n        info[\"end\"] = endNode.lineno\n\n        self.loops.update({\"for-\"+str(node.lineno):info})\n\n\n    def visit_Expr(self,node):\n        print(ast.dump(node))\n        if type(node.value) is ast.ListComp:\n            print(\"HERE\")\n            info = createInfo(node.value.lineno)\n            # endNode = self.get_last_child(node.body)\n\n            lines = build_code_line(self.source[node.value.lineno-1:])\n            lines = lines.split(\"\\n\")\n\n\n            info[\"end\"] =node.line + len(lines)\n\n            self.loops.update({\"for-\" + str(node.lineno): info})\n\n    def visit_FunctionDef(self,node):\n        for n in node.body:\n            self.visit(n)\n\n        info = createInfo(node.lineno)\n        endNode = self.get_last_child(node.body)\n\n        info[\"end\"] = endNode.lineno\n\n        self.functions.update({node.name: info})\n\n\nclass DependencyVisitor(ast.NodeVisitor):\n    def __init__(self):\n        self.contributors = {}\n        self.functionStack =[]\n\n    def visit_FunctionDef(self, node):\n        self.functionStack.append(node.name)\n        for n in node.body:\n            self.visit(n)\n        self.functionStack.pop(-1)\n\n    def visit_Assign(self, node):\n        targets = node.targets\n        val = node.value\n\n        if len(self.functionStack) > 0:\n            func = self.functionStack[-1]\n        else:\n            func = \"\"\n\n        keys = []\n        dependencies = []\n        targType = type(targets[0])\n\n        if targType is ast.Tuple:\n            elements = targets[0].elts\n            if type(val) is ast.Tuple:\n                valElts = val.elts\n                for i in range(len(elements)):\n                    dep = self.parse_expr(valElts[i])\n\n                    if type(elements[i]) is ast.Name:\n                        keys.append(func + \"_\" + elements[i].id)\n                        dependencies.append(dep)\n                    else:\n                        # print(\"UNHANDLED ASSIGNMENT: \", ast.dump(node))\n                        pass\n            elif type(val) is ast.Call:\n                dep = self.parse_expr(val)\n                for i in range(len(elements)):\n                    keys.append(func + \"_\" + elements[i].id)\n                    dependencies.append(dep)\n\n        elif type(targets[0]) is ast.Name:\n            deps = self.parse_expr(val)\n            keys.append(func + \"_\" + targets[0].id)\n            dependencies.append(deps)\n            # self.contributors.update({func + \"_\" + targets[0].id: deps})\n        else:\n            # print(\"UNHANDLED ASSIGNMENT: \", ast.dump(node))\n            pass\n        for i, keyname in enumerate(keys):\n            if keyname in self.contributors:\n                for d in dependencies[i]:\n                    self.contributors[keyname].append(d)\n            else:\n                self.contributors.update({keyname: dependencies[i]})\n\n    def visit_AugAssign(self, node):\n        target = node.target\n        val = node.value\n        if len(self.functionStack) > 0:\n            func = self.functionStack[len(self.functionStack) - 1]\n        else:\n            func = \"\"\n\n        keyname = None\n        dependencies = []\n        if type(target) is ast.Name:\n\n            deps = self.parse_expr(val)\n\n            keyname = func + \"_\" + target.id\n            dependencies = deps\n            dependencies.append(keyname)\n        else:\n            # print(\"UNHANDLED ASSIGNMENT: \", ast.dump(node))\n            pass\n\n        if keyname is not None:\n            if keyname in self.contributors:\n                for d in dependencies:\n                    self.contributors[keyname].append(d)\n            else:\n                self.contributors.update({keyname: dependencies})\n\n    def visit_Return(self, node):\n\n        if len(self.functionStack) > 0:\n            func = self.functionStack[len(self.functionStack) - 1]\n        else:\n            func = \"\"\n\n        name = func + \"_return\"\n        if node.value is not None:\n            dependencies = self.parse_expr(node.value)\n            self.contributors.update({name: dependencies})\n\n    def parse_expr(self, expr):\n        depends = []\n        if len(self.functionStack) > 0:\n            func = self.functionStack[- 1]\n        else:\n            func = \"\"\n        if type(expr) is ast.BinOp:\n            ldeps = self.parse_expr(expr.left)\n            rdeps = self.parse_expr(expr.right)\n            for d in ldeps:\n                depends.append(d)\n            for d in rdeps:\n                depends.append(d)\n        elif type(expr) is ast.Tuple:\n            elts = expr.elts\n            for e in elts:\n                deps = self.parse_expr(e)\n                for d in deps:\n                    depends.append(d)\n\n        elif type(expr) is ast.Name:\n            depends.append(func + \"_\" + expr.id)\n        elif type(expr) is ast.Call:\n\n            if type(expr.func) is ast.Name:\n                name = expr.func.id + str(expr.lineno)\n\n            elif type(expr.func) is ast.Attribute:\n\n                dep = self.parse_expr(expr.func.value)\n\n                if len(dep) > 0:\n                    ind = dep[0].find(func + \"_\")\n\n                    if ind > -1 and ind < len(func) + 1:\n                        dep[0] = dep[0].replace(func + \"_\", \"\")\n                    name = dep[0] + \".\" + expr.func.attr + str(expr.lineno)\n                else:\n                    name = \"\"\n\n            else:\n                # print(\"UNHANDLED CALL: \", ast.dump(expr.func))\n                # print(\"BROKE WITH LAMBDAS\")\n                name = \"\"\n            args = expr.args\n\n            depends.append(name)\n            deps2 = []\n            for arg in args:\n                dep = self.parse_expr(arg)\n                for d in dep:\n                    deps2.append(d)\n\n            if name in self.contributors:\n                for d in deps2:\n                    self.contributors[name].append(d)\n            else:\n                self.contributors.update({name: deps2})\n\n        elif type(expr) is ast.Num:\n            pass\n        elif type(expr) is ast.Attribute:\n            dep = self.parse_expr(expr.value)\n            depends.append(dep[0] + \".\" + expr.attr)\n        elif type(expr) is ast.Str:\n            pass\n            # Nothing needs to happen for hardcoded strings, no dependencies there\n        elif type(expr) is ast.Subscript:\n            # build subscript expression, make all indices dependencies\n            name = \"\"\n            curExpr = expr\n\n            while type(curExpr.value) is ast.Subscript:\n                n = \"[\"\n                if type(curExpr.slice.value) is ast.Name:\n                    n += curExpr.slice.value.id\n                elif type(curExpr.slice.value) is ast.Num:\n                    n += str(curExpr.slice.value.n)\n                elif type(curExpr.slice.value) is ast.Str:\n                    n += curExpr.slice.value.s\n                else:\n                    # print(\"UNHANDLED INDEX TYPE\")\n                    pass\n                n += \"]\"\n                name = n + name\n                curExpr = curExpr.value\n\n            depends.append(func + \"_\" + name)\n        else:\n            # print(\"UNHANDLED: \", ast.dump(expr))\n            pass\n        return depends\n\nclass JoinVisitor(ast.NodeVisitor):\n\n    def __init__(self):\n        pass\n\n\nclass PathVisitor(ast.NodeVisitor):\n\n    def __init__(self):\n        pass\n\n\n\n\nif __name__==\"__main__\":\n    f = open(\"../../instance/uploads/broken/broken.py\", \"r\")\n    text = f.read()\n    f.close()\n    head = generateHead(text)\n\n    visitor = CallExtentVisitor(text.split(\"\\n\"))\n    visitor.visit(head)\n    functions = visitor.functions\n    loops = visitor.loops\n"