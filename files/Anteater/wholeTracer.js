tracerCode="t = None\nsource = \"test\"\n\nimport astor\nprint(\"done\")\n\nimport ast\nimport numpy as np\nimport re\nimport uuid\nimport time\nimport datetime\nimport os\nimport sys\nfrom io import StringIO\n\nclass ExclusionObject:\n    def __init__(self, name, func, lineno, containingFuncStr):\n        self.name = name\n        self.lineno = lineno\n        self.containingFuncStr = containingFuncStr\n        self.func = func\n\n        self.length = len(name)\n\nclass TrackObject:\n    def __init__(self, name, var, lineno, offset, containingFuncStr, custom=None):\n        self.name = name\n        self.var = var\n        self.custom = custom\n        self.lineno = lineno\n        self.offset = offset\n        self.containingFunc = containingFuncStr\n        self.origName = name\n        self.length = len(name)\n        self.id = str(uuid.uuid4().hex)\n        self.tracked = False\n\n\n\nclass TranfsormerHelpers:\n\n    def __init__(self,variables,expressions, exclusions,visitor,excludedFuncs,excludedLibs,source,extractedCalls, extractedComprehensions):\n        self.expressions = expressions\n        self.variables = variables\n        self.exclusions = exclusions\n        self.loopCounterIDStack = []\n        self.visitor = visitor\n        self.blockStack = []\n        self.id = visitor.id\n        self.excludedFuncs = excludedFuncs\n        self.excludedLibs = excludedLibs\n        self.source = source\n        self.extractedCalls =extractedCalls\n        self.extractedComprehensions = extractedComprehensions\n        self.instances = {}\n\n        for v in variables:\n            self.instances.update({v:[]})\n\n    #function to parse a string of source code into AST nodes\n    def parse_code(self,code, lineno):\n        n = ast.parse(code)\n        body = []\n        for node in n.body:\n            node.lineno = lineno\n            body.append(node)\n        return body\n\n\n    def check_exclusion(self,node):\n\n        #TODO: If normal, non attribute call just build the name and check it\n        nodeType = type(node.func)\n        fStr = self.create_containing_function_str()\n        if nodeType is ast.Name:\n            fname = self.create_function_name(node.func)\n            if fname in self.excludedFuncs:\n                i =0\n                while i < len(self.exclusions):\n                    excl =  self.exclusions[i]\n                    if excl.func and excl.name == fname:\n                        if excl.containingFuncStr ==\"\":\n                            return True\n                        elif fStr.find(excl.containingFuncStr) >-1:\n                            return True\n                    i+=1\n        # TODO: If attribute call, check the whole thing, the final attribute (the actual call),\n        # TODO:  and the initial object (in case it is amn excluded libarary)\n        elif nodeType is ast.Attribute:\n            wholeName = self.create_function_name(node.func)\n            final =wholeName[wholeName.rfind(\".\")+1:]\n            lib = wholeName[:wholeName.find(\".\")]\n\n            if final in self.excludedFuncs:\n                i = 0\n                while i < len(self.exclusions):\n                    excl = self.exclusions[i]\n                    if excl.func and excl.name == final:\n                        if excl.containingFuncStr == \"\":\n                            return True\n                        elif fStr.find(excl.containingFuncStr) > -1:\n                            return True\n                    i+=1\n\n            if lib in self.excludedLibs:\n                return True\n\n        return False\n\n\n    def finish_node(self,body, node, nodeType,recordAttrs,footer = True, closeBody = False):\n        if node.lineno in self.expressions:\n            body,node = self.create_expr_nodes(node,node.lineno,body,recordAttrs)\n\n        else:\n            body.append(node)\n\n        if footer:\n            body = list(np.concatenate((body,self.create_closing_nodes(nodeType,node.lineno,closeBody))))\n\n        return body\n\n    def create_containing_function_str(self):\n        funcStack = self.visitor.functionStack\n        fStr = \"\"\n        first = True\n        for f in funcStack:\n            if not first:\n                fStr+=\"_\"\n            else:\n                first = False\n            fStr+=f[0]\n        return  fStr\n\n    def create_function_name(self,n):\n\n        name = astor.to_source(n)\n        cutoff = name.find(\"(\")\n        name = name[:cutoff]\n        return name\n\n    #Method that wraps source nodes with other nodes to collect information about htem\n    def wrap_node(self,n, body,  parentAttrs = None):\n        nodeType = type(n)\n        recordAttrs = {}\n        if parentAttrs is not None:\n            recordAttrs.update(parentAttrs)\n\n\n\n        #wrap the different node types in the appropriate nodes\n        if nodeType is ast.For:\n            # Before the loop, record the standard info about the loop.\n            # Add an iteration counter that increments with each loop execution\n            # For each child, have it record the iteration number\n            body = list(np.concatenate((body,self.generate_tab_nodes(n.lineno))))\n\n            #check if the for loop has a tuple of variables it is iterating over\n            if type(n.target) is ast.Tuple:\n                for i,target in enumerate(n.target.elts):\n                    targetName = target.id\n                    recordAttrs.update({\"target\" +str(i+1) : \"\\\"\" + targetName + \"\\\"\"})\n                body=list(np.concatenate((body,self.create_opening_nodes(\"for\",n.lineno,recordAttrs, body = True, globals=False))))\n            else:\n                targetName = n.target.id\n                recordAttrs.update({\"target\":\"\\\"\"+targetName+ \"\\\"\"})\n                body = list(np.concatenate((body,self.create_opening_nodes(\"for\",n.lineno,recordAttrs,body = True, globals=False))))\n\n            loopId = \"f\" + str(uuid.uuid4().hex) +\"ind\"\n            while loopId in self.loopCounterIDStack:\n                loopId = \"f\" + str(uuid.uuid4().hex) + \"ind\"\n            self.loopCounterIDStack.append(loopId)\n            body = list(np.concatenate((body,self.parse_code(loopId + \"=0\",n.lineno))))\n\n            n = self.visitor.visit(n)\n            body = self.finish_node(body,n, \"for\", recordAttrs,True,True)\n            self.loopCounterIDStack.pop()\n\n\n        elif nodeType is ast.While:\n            body = list(np.concatenate((body,self.generate_tab_nodes(n.lineno))))\n            body = list(np.concatenate((body, self.create_opening_nodes(\"while\", n.lineno, recordAttrs, body = True, globals=False))))\n\n            loopId = \"f\" + str(uuid.uuid4().hex) + \"ind\"\n            while loopId in self.loopCounterIDStack:\n                loopId = \"f\" + str(uuid.uuid4().hex) + \"ind\"\n            self.loopCounterIDStack.append(loopId)\n            body = list(np.concatenate((body,self.parse_code(loopId + \"=0\",n.lineno))))\n\n\n            n = self.visitor.visit(n)\n            body = self.finish_node(body, n, \"while\", recordAttrs, True, True)\n            self.loopCounterIDStack.pop()\n\n\n        elif nodeType is ast.Expr and type(n.value) is ast.Call:\n            n = self.visitor.visit(n)\n            body = list(np.concatenate((body,self.generate_tab_nodes(n.lineno))))\n            if not self.check_exclusion(n.value):\n\n                recordAttrs.update({\"func_name\" : \"\\\"\"+self.create_function_name(n.value)+\"\\\"\" })\n\n                body = list(np.concatenate((body, self.create_opening_nodes(\"call\", n.lineno, recordAttrs, body=True,\n                                                                            globals=False))))\n                body = self.finish_node(body, n, \"call\", recordAttrs, True, True)\n            else:\n                self.finish_node(body,n,\"call\",recordAttrs,False,False)\n\n\n        elif nodeType is ast.Return:\n            n = self.visitor.visit(n)\n\n            if n.lineno in self.expressions:\n                body, n = self.create_expr_nodes(n,n.lineno,body,recordAttrs,False)\n\n\n            if len(self.visitor.functionStack) > 0:\n                for block in self.visitor.functionStack[-1][1]:\n                    # body = self.create_closing_nodes(block,n.lineno,body)\n                    body = list(np.concatenate((body, self.create_closing_nodes(block, n.lineno, True))))\n\n            body.append(n)\n\n\n\n        elif nodeType is ast.Assign or nodeType is ast.AugAssign:\n\n            n = self.visitor.visit(n)\n            body = list(np.concatenate((body, self.generate_tab_nodes(n.lineno))))\n            targets = []\n            targetNames = []\n            if type(n) is ast.AugAssign:\n                targets = [n.target]\n                targetNames = [astor.to_source(n.target).strip()]\n            elif type(n.targets[0]) is ast.Tuple:\n                for t in n.targets[0].elts:\n                    targets.append(t)\n                    targetNames.append(astor.to_source(t).strip())\n            else:\n                targets.append(n.targets[0])\n                targetNames.append(astor.to_source(n.targets[0]).strip())\n\n            call = False\n            if type(n.value) is ast.Call and not self.check_exclusion(n.value):\n                callAttrs= recordAttrs.copy()\n                callAttrs.update({\"func_name\":\"\\\"\" + self.create_function_name(n.value).strip() + \"\\\"\"})\n\n                body = list(np.concatenate((body,self.create_opening_nodes(\"call\",n.lineno,callAttrs,body = True, globals = False))))\n                call = True\n\n            if n.lineno in self.expressions:\n                body,n= self.create_expr_nodes(n,n.lineno,body,recordAttrs)\n            else:\n                body.append(n)\n\n            if call:\n                body = list(np.concatenate((body,self.create_closing_nodes(\"call\",n.lineno,True))))\n\n\n            fStr = self.create_containing_function_str()\n\n            for i,target in enumerate(targets):\n                additionalAttrs= {}\n                tName = targetNames[i]\n                if tName in self.variables:\n                    additionalAttrs.update(recordAttrs)\n                    nTracked = len(self.visitor.tracked)\n                    i = 0\n                    obj = self.visitor.tracked[i]\n                    while i < nTracked - 1 and (obj.name !=tName or obj.containingFunc != fStr):\n                        i+=1\n                        obj = self.visitor.tracked[i]\n\n                    if obj.containingFunc == fStr:\n                        self.instances[tName].append([n.lineno,target.col_offset])\n\n                        targetLbl = tName.replace(\"\\\"\",\"\\\\\\\"\")\n\n                        additionalAttrs.update({\"name\": \"\\\"\"+str(targetLbl)+\"\\\"\"})\n                        additionalAttrs.update({targetLbl:tName})\n                        if obj.custom is not None and len(obj.custom) > 0:\n                            for i, e in enumerate(obj.custom):\n                                f = open(\"custom.txt\", \"r\")\n                                text = f.read()\n                                f.close()\n                                text = text.replace(\"REPLACE_I\", str(i))\n                                text = text.replace(\"EXPR\", e)\n                                nodes = self.parse_code(text, n.lineno)\n                                body = np.concatenate((body,nodes))\n                                additionalAttrs.update({e.replace(\"\\\"\",\"\\\\\\\\\\\\\\\"\"):\"cExp\"+str(i)})\n\n\n                        body = list(np.concatenate((body,self.create_opening_nodes(\"assign\", n.lineno, additionalAttrs,body=False,globals=False))))\n                        body= list(np.concatenate((body,self.create_closing_nodes(\"assign\",n.lineno,False))))\n\n\n\n\n        elif nodeType is ast.If:\n            # This doesn't really belong here but things are weird\n            self.visitor.visit(n.test)\n            ifBody = []\n            elseBody = []\n            for node in n.body:\n                ifBody = self.wrap_node(node,ifBody,recordAttrs)\n            if n.orelse is not None:\n                for node in n.orelse:\n                    elseBody = self.wrap_node(node,elseBody,recordAttrs)\n            n.body = ifBody\n            n.orelse = elseBody\n            body = self.finish_node(body,n,\"if\",recordAttrs,False,False)\n\n        elif nodeType is ast.arg:\n            if n.arg in self.variables:\n                i=0\n                nTracked = len(self.visitor.tracked)\n                while i < nTracked and (self.visitor.tracked[i].name != n.arg or self.visitor.tracked[i].lineno !=n.lineno):\n                    i += 1\n                if i < nTracked:\n                    self.instances[n.arg].append([n.lineno,n.col_offset])\n                    additionalAttrs = {\"name\": \"\\\"\" + str(n.arg) + \"\\\"\",n.arg: n.arg}\n                    obj = self.visitor.tracked[i]\n                    if obj.custom is not None and len(obj.custom) > 0:\n                        for i, e in enumerate(obj.custom):\n                            f = open(\"custom.txt\", \"r\")\n                            text = f.read()\n                            f.close()\n                            text = text.replace(\"REPLACE_I\", str(i))\n                            text = text.replace(\"EXPR\", e)\n                            nodes = self.parse_code(text, n.lineno)\n                            body = np.concatenate((body, nodes))\n                            additionalAttrs.update({e.replace(\"\\\"\", \"\\\\\\\\\\\\\\\"\"): \"cExp\" + str(i)})\n\n                    body = list(np.concatenate((body, self.create_opening_nodes(\"param\", n.lineno,additionalAttrs , False, False))))\n                    body = list(np.concatenate((body, self.create_closing_nodes(\"param\", n.lineno, False))))\n\n        # elif nodeType is ast.Expression and type(n.value) is ast.ListComp:\n        #     f = open(\"listCompToFor.txt\")\n        #     text = f.read()\n        #     f.close()\n        #     text = text.replace(\"REPLACEEXPR\", astor.to_source(n.elt))\n        #     generator = n.generators[0]\n        #     text = text.replace(\"REPLACEV\", astor.to_source(generator.target).strip())\n        #\n        #     text = text.replace(\"REPLACERANGE\", astor.to_source(generator.iter).strip())\n        #\n        #     if (len(generator.ifs) > 0):\n        #         text = text.replace(\"REPLACEIF\", astor.to_source(generator.ifs[0]).strip())\n        #     else:\n        #         text = text.replace(\"REPLACEIF\", \"true\")\n        #\n        #     fname = \"f\" + str(uuid.uuid4().hex) +\"gen\"\n        #\n        #     text = text.replace(\"REPLACEFUNC\",fname)\n        #\n        #\n        #     n = self.parse_code(\"list(\" + fname + \")\",n.lineno)[0]\n        #\n        #     for_node = self.parse_code(text,n.lineno)[0]\n        #     for node in for_node.body:\n        #         node.lineno = n.lineno\n        #\n        #     body = self.wrap_node(for_node,body,parentAttrs)\n\n\n            #split line into three parts: expr, for, and if\n            # line = self.source[n.lineno-1]\n            # if_ind = line.find(\"if\")\n            # if if_ind > -1:\n            #     if_ind += 2\n            # for_ind = line.find(\"for\") + 3\n            # expr_ind = 0\n\n            # body = list(np.concatenate((body, self.generate_tab_nodes(n.lineno))))\n\n            # check if the for loop has a tuple of variables it is iterating over\n            # if type(for_node.target) is ast.Tuple:\n            #     for i, target in enumerate(for_node.target.elts):\n            #         targetName = target.id\n            #         recordAttrs.update({\"target\" + str(i + 1): \"\\\"\" + targetName + \"\\\"\"})\n            #     body = list(np.concatenate(\n            #         (body, self.create_opening_nodes(\"for\", for_node.lineno, recordAttrs, body=True, globals=False))))\n            # else:\n            #     targetName = for_node.target.id\n            #     recordAttrs.update({\"target\": \"\\\"\" + targetName + \"\\\"\"})\n            #     body = list(np.concatenate(\n            #         (body, self.create_opening_nodes(\"for\", for_node.lineno, recordAttrs, body=True, globals=False))))\n            #\n            # loopId = \"f\" + str(uuid.uuid4().hex) + \"ind\"\n            # while loopId in self.loopCounterIDStack:\n            #     loopId = \"f\" + str(uuid.uuid4().hex) + \"ind\"\n            # self.loopCounterIDStack.append(loopId)\n            # body = list(np.concatenate((body, self.parse_code(loopId + \"=0\", n.lineno))))\n            #\n            # n = self.visitor.visit(n)\n            # body = self.finish_node(body, n, \"for\", recordAttrs, True, True)\n            # self.loopCounterIDStack.pop()\n\n\n\n            # tokens = line.split(\"if\")\n            # if len(tokens) >1:\n            #     comp_if = line.split(\"if\")[1]\n            # else:\n            #     comp_if = \"\"\n            # comp_for =\n\n\n        else:\n            self.visitor.visit(n)\n            body = self.finish_node(body,n,\"\",recordAttrs,False,False)\n\n        return body\n\n\n    def create_opening_nodes(self,nodeType, lineno, attr, globals, body):\n        # create node for id\n        nodes = []\n        if globals:\n            gNode =ast.Global(names=[self.id + \"startTime\"])\n            gNode.lineno = lineno\n            nodes.append(gNode)\n\n        f = open(\"RecordHeader.txt\", \"r\")\n        text = f.read()\n        f.close()\n        text = text.replace(\"REPLACE\",self.id)\n        text = text.replace(\"REPLINENO\",str(lineno))\n        text = text.replace(\"RTYPE\",nodeType)\n\n        nodes = list(np.concatenate((nodes, self.parse_code(text,lineno))))\n\n        for key in attr.keys():\n            # \"str + = tabstr + \\\"\\t\\\"\\\\\\\"key \\\\\\\" \\\":\\\"\"\n            # n = ast.AugAssign(target = ast.Name(id=str(self.id+\"str\"),ctx=ast.Store()),op=ast.Add(), value=ast.BinOp(\n            #     left=ast.Name(id=str(self.id+\"tabstr\"),ctx=ast.Load()),op=ast.Add(), right = ast.Str(s=str(\"\\t\\\"\"+str(key)+\"\\\":\"))))\n            # n.lineno = lineno\n            # nodes.append(n)\n            nodes = list(np.concatenate((nodes,self.parse_code(self.id+\"str+= \"+self.id+\"tabstr+\\\"\\\\t\\\\\\\"\"+str(key)+\"\\\\\\\":\\\"\",lineno))))\n            if type(attr[key]) is dict:\n                n = ast.AugAssign(target = ast.Name(id=str(self.id+\"str\"),ctx=ast.Store()),op=ast.Add(), value=ast.BinOp(\n                left=ast.Name(id=str(self.id+\"tabstr\"),ctx=ast.Load()),op=ast.Add(), right = ast.Str(s=str(\"\\t{\\n\\\"\"))))\n                n.lineno = lineno\n                nodes.append(n)\n\n                for i,k2 in enumerate(attr[key].keys()):\n                    if i >0:\n                        n = ast.AugAssign(target=ast.Name(id=str(self.id + \"str\"), ctx=ast.Store()), op=ast.Add(),\n                                          value=ast.Str(s=\",\\n\"))\n                        n.lineno = lineno\n                        nodes.append(n)\n                    n = ast.AugAssign(target=ast.Name(id=str(self.id + \"str\"), ctx=ast.Store()), op=ast.Add(), value=ast.BinOp(\n                        left=ast.BinOp(left=ast.Name(id=str(self.id + \"tabstr\"), ctx=ast.Load()), op=ast.Add(),\n                            right =ast.Str(s=str(\"\\\"\"+str(k2)+\"\\\":\"))),op=ast.Add(),right =ast.Call(func=ast.Name(\n                                id=str(self.id+\"funcstr\"),ctx=ast.Load()),args=[ast.Name(id=str(attr[key][k2]),ctx=ast.Load())],keywords=[])))\n                    n.lineno = lineno\n                    nodes.append(n)\n\n            else:\n                nodes = list(np.concatenate((nodes,self.parse_code(self.id+\"str+=\"+self.id+\"funcstr(\"+attr[key]+\")+\\\",\\\\n\\\"\",lineno))))\n                # n = ast.AugAssign(target=ast.Name(id=str(self.id + \"str\"), ctx=ast.Store()), op=ast.Add(), value=ast.BinOp(\n                #     left=ast.Call(func=ast.Name(id=str(self.id+\"funcstr\"),ctx=ast.Load()),args=[ast.Str(s=str(attr[key]))],keywords=[]), op=ast.Add(),\n                #     right=ast.Str(s=\",\\n\")))\n                # n.lineno = lineno\n                # nodes.append(n)\n                pass\n\n        if body:\n            n = ast.AugAssign(target=ast.Name(id=self.id+\"str\", ctx=ast.Store()),op=ast.Add(),value = ast.BinOp(left=ast.Name(id=self.id+\"tabstr\",\n                                          ctx = ast.Load()),op=ast.Add(),right=ast.Str(s=\"\\t\\\"body\\\":[\\n\")))\n            n.lineno = lineno\n            nodes.append(n)\n\n            n = ast.Expr(value=ast.Call(func=ast.Attribute(value=ast.Name(id=self.id+\"closingStack\",ctx = ast.Load()), attr='append',ctx=ast.Load()),args=[ast.Str(s=\"]\")],keywords=[]))\n            n.lineno = lineno\n            nodes.append(n)\n\n        else:\n            n = ast.AugAssign(target=ast.Name(id=self.id + \"str\",ctx = ast.Store()), op=ast.Add(),value=ast.Str(s=\"DELETE\\n\"))\n            n.lineno = lineno\n            nodes.append(n)\n\n\n        if nodeType is \"for\" or nodeType is \"while\" or nodeType is \"call\":\n            # add node id to the stack of blocks (so all its children will match with it)\n            blockNode = ast.Expr(\n                value=ast.Call(func=ast.Attribute(value=ast.Name(id=self.id + \"blockStack\", ctx=ast.Load()),\n                                                  attr=\"append\", ctx=ast.Load()),\n                               args=[ast.Name(id=self.id + \"curID\", ctx=ast.Load())],keywords=[]))\n            blockNode.lineno = lineno\n            nodes.append(blockNode)\n\n\n        n = ast.Expr(value=ast.Call(func=ast.Attribute(value=ast.Name(id=self.id,ctx=ast.Load()),attr=\"write\",ctx=ast.Load()),\n                     args=[ast.Name(id=self.id+\"str\",ctx=ast.Load())],keywords=[]))\n        n.lineno = lineno\n        nodes.append(n)\n\n        n = ast.AugAssign(target=ast.Name(id=self.id+\"Tabs\",ctx= ast.Store()),op=ast.Add(),value=ast.Num(n=1))\n        n.lineno = lineno\n        nodes.append(n)\n\n\n        return nodes\n\n\n    def create_closing_nodes(self,nodeType,lineno,body):\n        nodes = []\n        if nodeType is \"for\" or nodeType is \"while\" or nodeType is \"call\":\n\n            blockNode = ast.Expr(\n                value=ast.Call(func=ast.Attribute(value=ast.Name(id=self.id + \"blockStack\", ctx=ast.Load()),\n                                                  attr=\"pop\", ctx=ast.Load()),\n                               args=[ast.UnaryOp(op=ast.USub(), operand=ast.Num(n=1))],keywords=[]))\n            blockNode.lineno = lineno\n\n            nodes.append(blockNode)\n\n        n = ast.AugAssign(target=ast.Name(id=self.id + \"Tabs\",ctx = ast.Store()), op=ast.Sub(), value=ast.Num(n=1))\n        n.lineno = lineno\n        nodes.append(n)\n        nodes = list(np.concatenate((nodes,self.generate_tab_nodes(False))))\n\n        n = ast.Assign(targets=[ast.Name(id=self.id + \"str\", ctx = ast.Store())], value=ast.Str(s=\"DELETE\\n\"))\n        n.lineno = lineno\n        nodes.append(n)\n\n        if body:\n\n            n = ast.AugAssign(target=ast.Name(id=self.id + \"str\", ctx = ast.Store()), op=ast.Add(),\n                              value=ast.BinOp(left=ast.Name(id=self.id + \"tabstr\",\n                                                            ctx=ast.Load()), op=ast.Add(),\n                                              right=ast.Str(s=\"\\t]\\n\")))\n            n.lineno = lineno\n            nodes.append(n)\n\n            n = ast.Expr(value=ast.Call(func=ast.Attribute(value=ast.Name(id=self.id + \"closingStack\", ctx=ast.Load()), attr='pop',\n                                            ctx=ast.Load()), args=[],keywords = []))\n            n.lineno = lineno\n            nodes.append(n)\n\n        n = ast.AugAssign(target=ast.Name(id=self.id + \"str\",ctx =ast.Store()), op=ast.Add(),\n                          value=ast.BinOp(left=ast.Name(id=self.id + \"tabstr\",\n                                                        ctx=ast.Load()), op=ast.Add(),\n                                          right=ast.Str(s=\"},\\n\")))\n        n.lineno = lineno\n        nodes.append(n)\n\n        n = ast.Expr(value=ast.Call(func=ast.Attribute(value=ast.Name(id=self.id + \"closingStack\", ctx=ast.Load()), attr='pop',\n                                        ctx=ast.Load()), args=[], keywords=[]))\n        n.lineno = lineno\n        nodes.append(n)\n\n        n = ast.Expr(value = ast.Call(func=ast.Attribute(value=ast.Name(id=self.id, ctx=ast.Load()), attr=\"write\", ctx=ast.Load()),\n                     args=[ast.Name(id=self.id+\"str\",ctx = ast.Load())], keywords=[]))\n        n.lineno = lineno\n        nodes.append(n)\n\n        return nodes\n\n\n\n    def build_code_line(self,lines):\n\n\n        ind = 0\n        curLine = lines[ind].strip()\n        whitespace = lines[ind][:lines[ind].find(lines[ind].strip())]\n        blockStack = []\n        lineInd = 0\n        inString = False\n        curQuote = None\n        lineText = whitespace + lines[ind].strip()\n        # print(curLine)\n        while (lineInd < len(curLine) or len(blockStack) > 0):\n\n            if curLine[lineInd] == \"\\\"\" or curLine[lineInd] == \"'\":\n                if inString and curLine[lineInd] == curQuote:\n                    curQuote = None\n                    inString = False\n                elif not inString:\n                    inString = True\n                    curQuote = curLine[lineInd]\n\n            if not inString:\n                if curLine[lineInd] == \"[\" or curLine[lineInd] == \"(\" or curLine[lineInd] == \"{\":\n                    blockStack.append(curLine[lineInd])\n                elif curLine[lineInd] == \"]\" or curLine[lineInd] == \")\" or curLine[lineInd] == \"}\":\n                    blockStack.pop()\n            lineInd += 1\n\n            if lineInd == len(curLine) and len(blockStack) > 0:\n                ind += 1\n                whitespace = lines[ind][:lines[ind].find(lines[ind].strip())]\n                curLine = lines[ind].strip()\n                lineText += \"\\n\"+whitespace + curLine\n                lineInd = 0\n\n        return lineText\n\n    def create_expr_nodes(self,n,lineno,body,attrs,append = True):\n        if attrs is None:\n            attrs={}\n\n        inds =[]\n        afterbody = []\n        nTracked = len(self.visitor.tracked)\n        for i in range(nTracked):\n            if self.visitor.tracked[i].lineno == lineno and not self.visitor.tracked[i].var and not self.visitor.tracked[i].tracked:\n                inds.append(i)\n\n        if len(inds) > 0:\n            #copy the original text to build the new line\n            # newLine =self.source[lineno-1]\n            newLine = self.build_code_line(self.source[lineno-1:])\n            print(newLine)\n\n            callKeys = list(self.extractedCalls.keys())\n\n            extractedOffsets = []\n            if lineno in callKeys:\n                extractedOffsets = list(self.extractedCalls[lineno].keys())\n\n            extractedOffsets.sort()\n\n            #replace all function calls in the line from back to front\n            for i in range(len(extractedOffsets)-1,-1,-1):\n                #TODO: assumes call is on a single line (fix later)\n                offset = extractedOffsets[i]\n                call = self.extractedCalls[lineno][offset]\n                beginning = newLine[:offset]\n                newMiddle = call[0]\n\n                #search the current newline for the closing parentheses\n                l = newLine[offset:]\n\n                ind = l.find(\"(\") + 1\n                openParenthCt = 1\n                # search for the closing parentheses of the call, keeping track of all parentheses in case of nested calls\n                while openParenthCt > 0:\n                    if l[ind] == \"(\":\n                        openParenthCt += 1\n                    elif l[ind] == \")\":\n                        openParenthCt -= 1\n                    ind += 1\n\n                ending = newLine[offset + len(self.extractedCalls[lineno][offset][1]):]\n                newLine = beginning + newMiddle + ending\n            print(\"After replacement \" ,newLine)\n\n\n                    # for ind in range(3,len(newLines)-1):\n                    #     compLine = ind\n                    #     lineText = self.build_code_line(newLines[ind:])\n                    #     print(lineText)\n                    #     n2 = ast.parse(lineText.strip()).body[0]\n                    #\n                    #     if type(n2) is ast.Assign and n.targets[0].id == n2.targets[0].id:\n                    #         newLine = lineText\n                    #\n                    #         break\n\n\n            inds.sort(key=lambda x: self.visitor.tracked[x].offset)\n            print(\"Before: \", newLine)\n            for j in range(len(inds)):\n                i = inds[j]\n\n                expr = self.visitor.tracked[i]\n                original_offset = expr.offset\n                afterbody = None\n                if expr.custom:\n                    pass\n                #check if an expression starting at a changed offset is present\n                #The expression may have been extracted into a variable already\n                elif expr.offset in extractedOffsets:\n                    curAttrs = attrs.copy()\n                    print(ast.dump(n))\n                    print(self.extractedCalls[lineno][expr.offset][0])\n                    print(self.extractedCalls[lineno][expr.offset][1].strip())\n                    if type(n) is ast.Assign and n.targets[0].id == self.extractedCalls[lineno][expr.offset][0] and \\\n                        expr.name == self.extractedCalls[lineno][expr.offset][1].strip():\n                        curAttrs.update({\"name\":\"\\\"\" + str(expr.name) + \"\\\"\"})\n                        print(\"EXPR ATTR 1: \",curAttrs)\n                        #\n                        # afterbody = self.generate_tab_nodes(lineno,False)\n                        # afterbody = list(np.concatenate((afterbody,self.create_opening_nodes(\"expression\",lineno,curAttrs,False,False))))\n                        # afterbody = list(np.concatenate((afterbody,self.create_closing_nodes(\"expression\",lineno,False))))\n\n                    else:\n                        print(\"here\")\n                        # need to make sure that we have found the actual expression node, not one we extracted but\n                        #gave the same line number\n                        origNode = self.parse_code(self.source[lineno-1].strip(),lineno)[0]\n                        if type(origNode) == type(n):\n                            #they are the same type but need to make sure they are the same node.\n                            #nodes created during extraction are: a new assignment\n                            exprText = self.source[lineno-1][expr.offset:]\n                            for i in range(len(extractedOffsets) - 1, -1, -1):\n                                offset = extractedOffsets[i]\n                                if offset >= expr.offset:\n                                    call = self.extractedCalls[lineno][offset]\n                                    beginning = exprText[:offset-expr.offset]\n                                    newMiddle = call[0]\n                                    # search the current newline for the closing parentheses\n                                    l = exprText[offset-expr.offset:]\n\n                                    ind = l.find(\"(\") + 1\n                                    openParenthCt = 1\n                                    # search for the closing parentheses of the call, keeping track of all parentheses in case of nested calls\n                                    while openParenthCt > 0:\n                                        if l[ind] == \"(\":\n                                            openParenthCt += 1\n                                        elif l[ind] == \")\":\n                                            openParenthCt -= 1\n                                        ind += 1\n\n                                    ending = exprText[ind:]\n                                    exprText = beginning + newMiddle + ending\n\n                            match = False\n                            if type(n) is ast.Assign:\n                                if origNode.targets[0].id==n.targets[0].id:\n                                    match= True\n                            else:\n                                print(\"TOOD: EXPR NOT ASSIGN\")\n\n                            if match:\n                                f = open(\"exprFunc.txt\")\n                                text =f.read()\n                                f.close()\n                                text = text.replace(\"REPLACE\",expr.id)\n                                text = text.replace(\"EXPR\", exprText)\n\n                                self.excludedFuncs.append(\"function\"+expr.id)\n                                fStr = self.create_containing_function_str()\n\n                                self.exclusions.append(ExclusionObject(\"function\"+expr.id,True, expr.lineno, fStr))\n\n                                funcNode = self.parse_code(text,lineno)[0]\n\n                                curAttrs.update({\"name\":\"\\\"\" + str(expr.name) + \"\\\"\"})\n                                curAttrs.update({expr.name: \"temp\"+expr.id})\n\n                                print(\"EXPR ATTR: \", curAttrs)\n\n                                tabNodes = self.generate_tab_nodes(lineno, True)\n                                headNodes = self.create_opening_nodes(\"expression\",lineno,curAttrs,True,False)\n                                footNodes = self.create_closing_nodes(\"expression\",lineno,False)\n\n                                funBody = [funcNode.body[0]]\n                                funBody = list(np.concatenate((funBody, tabNodes)))\n                                funBody = list(np.concatenate((funBody,headNodes)))\n                                funBody = list(np.concatenate((funBody,footNodes)))\n                                funBody.append(funcNode.body[1])\n\n                                funcNode.body = funBody\n\n                                body.append(funcNode)\n\n                                front = newLine[:expr.offset]\n\n                                tail = newLine[expr.offset + len(exprText):]\n\n                                if type(n) is ast.Return:\n                                    l = front + \"function\"+expr.id +\"()\" +tail\n                                    l.strip()\n                                    l = \"def temp(): +\\n\\t\"+l\n\n                                    n=self.parse_code(l)[0].body[0]\n                                elif type(n) is ast.While or type(n) is ast.For:\n                                    l = front + \"function\"+expr.id +\"()\" +tail\n                                    l = l.strip()\n                                    l+=\"\\n\\tpass\"\n                                    newN = self.parse_code(l, lineno)[0]\n                                    newN.body = n.body\n                                    n = newN\n                                elif type(n) is ast.If:\n                                    l = front + \"function\" + expr.id + \"() \" + tail\n                                    l = l.strip()\n                                    l += \"\\n\\tpass\"\n                                    for k in range(j + 1, len(inds)):\n\n                                        if self.visitor.tracked[inds[k]].offset > expr.offset:\n                                            self.visitor.tracked[inds[k]].offset += len(\n                                                \"function\" + expr.id + \"() \") - len(\n                                                expr.name)\n\n                                    newN = self.parse_code(l, lineno)[0]\n                                    newN.body = n.body\n                                    n = newN\n                                else:\n                                    l = front + \"function\" + expr.id + \"() \" + tail\n                                    # newLineText = l\n\n                                    l = l.strip()\n                                    for k in range(j + 1, len(inds)):\n                                        if self.visitor.tracked[k].offset > expr.offset:\n                                            self.visitor.tracked[k].offset += len(\n                                                \"function\" + expr.id + \"() \") - len(expr.name)\n                                    n = self.parse_code(l, lineno)[0]\n                                newLine = l\n\n                else:\n                    curAttrs = attrs.copy()\n\n                    exprText = expr.name\n                    print(\"EXPR: \", exprText)\n\n                    comprehensionKeys = self.extractedComprehensions.keys()\n                    compLine = -1\n                    if lineno in comprehensionKeys:\n                        newLine = self.extractedComprehensions[lineno][\"func\"].strip()\n                        newLines = newLine.split(\"\\n\")\n\n                        # TODO: assume that the if statement is not captured as an expression\n                        origLine = self.build_code_line(self.source[lineno - 1:])\n\n                        forInd = origLine.find(\"for\")\n                        ifInd = origLine.find(\"if\")\n\n                        if type(n) is ast.FunctionDef:\n                            break;\n                        elif type(n) is ast.For:\n                            newLine = newLines[1]\n                            if expr.offset < forInd:\n                                break;\n                        elif type(n) is ast.If:\n                            newLine = newLines[2]\n\n                            if ifInd ==-1 or expr.offset < ifInd:\n                                break;\n                        elif type(n) is ast.Expr and type(n.value) is ast.Yield:\n                            newLine = newLines[-1]\n\n                            for i in range(len(extractedOffsets) - 1, -1, -1):\n                                offset = extractedOffsets[i]\n                                call = self.extractedCalls[lineno][offset]\n                                #if it is contained completely in an extracted call\n                                if offset < forInd and expr.offset > offset and expr.offset  + expr.name < offset + len(call[1]):\n                                    break;\n                                else:\n                                    #TODO:: Hacky and not unbreakable\n                                    afterYield = newLine.find(\"yield\") + 6\n\n                                    expr.offset = afterYield + newLine[afterYield:].find(expr.name)\n\n\n                        elif type(n) is ast.Assign:\n                            needToBreak = False\n                            # TODO: might break with nested calls\n                            for i in range(len(extractedOffsets) - 1, -1, -1):\n                                offset = extractedOffsets[i]\n                                call = self.extractedCalls[lineno][offset]\n                                callLine = call[0] + \" = \" + call[1]\n                                if offset < forInd:\n                                    newLines.insert(-1, callLine)\n                                elif offset > ifInd:\n                                    newLines.insert(2, callLine)\n                                if call[0] == n.targets[0].id:\n                                    newLine = callLine\n\n                                    if offset < forInd and expr.offset < offset:\n                                        needToBreak =True\n                            if needToBreak:\n                                print(\"NEED TO BREAK\")\n                                break;\n                            origNode = ast.parse(origLine.strip()).body[0]\n\n                            if type(origNode) is ast.Assign:\n                                if astor.to_source(n.targets[0]) == astor.to_source(origNode.targets[0]):\n                                    break;\n\n\n                    for i in range(len(extractedOffsets) - 1, -1, -1):\n                        call = self.extractedCalls[lineno][extractedOffsets[i]]\n                        # callOffset = newLine.find(call[0])\n                        callOffset = extractedOffsets[i]\n\n                        # #call is contained in expression\n                        if callOffset >= expr.offset and callOffset < expr.offset + len(expr.name):\n                            # call = self.extractedCalls[lineno][extractedOffsets[i]]\n                            exprText = expr.name[:callOffset - expr.offset + 2] + call[0] + expr.name[callOffset - expr.offset +2 + len(call[1]):]\n\n                            expr.offset += newLine.find(call[0]) - callOffset -2\n\n\n                            print(exprText)\n\n                        elif expr.offset + len(expr.name) < callOffset:\n                            pass\n\n                        #check if expression is in call (as a parameter)\n                        if expr.offset > callOffset and  expr.offset + len(expr.name) < callOffset + len(call[1]):\n                            if not (type(n) is ast.Assign and n.targets[0].id ==self.extractedCalls[lineno][callOffset][0]):\n                                break\n                            else:\n                                line = self.source[lineno-1]\n                                firstInd = line.find(line.strip())\n                                newLine = line[:firstInd] + call[0] + \" = \" + call[1]\n                                expr.offset = len(line[:firstInd] + call[0] + \" = \") + call[1].find(expr.name)\n\n\n                        #check if expression is after call\n                        elif expr.offset > callOffset + len(call[1]):\n                            expr.offset = expr.offset - len(call[1]) + len(call[0])\n\n\n                    ind = expr.offset\n                    # need to make sure that we have found the actual expression node, not one we extracted but\n                    # gave the same line number\n                    if ind >=0:\n                        f = open(\"exprFunc.txt\")\n                        text = f.read()\n                        f.close()\n                        text = text.replace(\"REPLACE\", expr.id)\n                        text = text.replace(\"EXPR\", expr.name)\n\n                        self.excludedFuncs.append(\"function\" + expr.id)\n                        fStr = self.create_containing_function_str()\n\n                        self.exclusions.append(\n                            ExclusionObject(\"function\" + expr.id, True, expr.lineno, fStr))\n\n                        funcNode = self.parse_code(text, lineno)[0]\n                        curAttrs.update({\"name\": \"\\\"\" + str(expr.name) + \"\\\"\"})\n                        curAttrs.update({expr.name: \"temp\" + expr.id})\n\n\n                        tabNodes = self.generate_tab_nodes(lineno,True)\n                        headNodes = self.create_opening_nodes(\"expression\", lineno, curAttrs, True, False)\n                        footNodes = self.create_closing_nodes(\"expression\", lineno, False)\n\n                        funBody = [funcNode.body[0]]\n                        funBody = list(np.concatenate((funBody, tabNodes)))\n                        funBody = list(np.concatenate((funBody, headNodes)))\n                        funBody = list(np.concatenate((funBody, footNodes)))\n                        funBody.append(funcNode.body[1])\n\n                        funcNode.body = funBody\n\n                        body.append(funcNode)\n\n\n                        front = newLine[:expr.offset]\n\n                        tail = newLine[expr.offset + len(exprText):]\n\n                        if type(n) is ast.Return:\n                            l = front + \"function\" + expr.id + \"()\" + tail\n                            newLine = l\n\n                            l.strip()\n                            l = \"def temp(): +\\n\\t\" + l\n\n                            n = self.parse_code(l)[0].body[0]\n                        elif type(n) is ast.While or type(n) is ast.For:\n                            l = front + \"function\" + expr.id + \"()\" + tail\n                            newLine = l\n\n                            l = l.strip()\n                            l += \"\\n\\tpass\"\n                            newN = self.parse_code(l, lineno)[0]\n                            newN.body = n.body\n                            n = newN\n                        elif type(n) is ast.If:\n                            l = front + \"function\" + expr.id + \"() \" + tail\n                            newLine = l\n\n                            l = l.strip()\n                            l += \"\\n\\tpass\"\n                            for k in range(j + 1, len(inds)):\n\n                                if self.visitor.tracked[inds[k]].offset > expr.offset:\n                                    self.visitor.tracked[inds[k]].offset += len(\n                                        \"function\" + expr.id + \"() \") - len(\n                                        expr.name)\n\n                            newN = self.parse_code(l, lineno)[0]\n                            newN.body = n.body\n                            n = newN\n                        else:\n                            print(\"ELSE: \",newLine)\n                            l = front + \"function\" + expr.id + \"() \" + tail\n                            newLine = l\n                            print(\"ELSE AFTER: \",newLine)\n\n                            l = l.strip()\n                            for k in range(j + 1, len(inds)):\n                                if self.visitor.tracked[k].offset > expr.offset:\n                                    self.visitor.tracked[k].offset += len(\n                                        \"function\" + expr.id + \"() \") - len(expr.name)\n\n\n                            n = self.parse_code(l, lineno)[0]\n\n                            self.visitor.tracked[i].tracked = True\n                    else:\n\n                        nodes = self.generate_tab_nodes(lineno)\n                        curAttrs.update({expr.name:\"\\\"INVALID EXPRESSION\\\"\"})\n                        headNodes = self.create_opening_nodes(\"expression\", lineno, curAttrs, False, False)\n                        footNodes = self.create_closing_nodes(\"expression\", lineno, False)\n                        body  = list(np.concatenate((body, nodes)))\n                        body  = list(np.concatenate((body, headNodes)))\n                        body = list(np.concatenate((body, footNodes)))\n\n                expr.offset = original_offset\n\n        print(\"appended\")\n        if append:\n            body.append(n)\n        if afterbody is not None and len(afterbody ) >0:\n            body = list(np.concatenate((body,afterbody)))\n        return body,n\n\n    # function that generates the ast nodes to that will\n    # properly indent the JSON file\n    def generate_tab_nodes(self,lineno,globals=False):\n        nodes = []\n        if globals:\n            n = ast.Global(names=[self.id + \"Tabs\"])\n            n.lineno = lineno\n            nodes.append(n)\n\n            n = ast.Global(names=[self.id + \"curID\"])\n            n.lineno = lineno\n            nodes.append(n)\n\n        f = open(\"tabs.txt\",\"r\")\n        text = f.read()\n        f.close()\n        text = text.replace(\"REPLACE\",self.id)\n\n        nodes = list(np.concatenate((nodes,self.parse_code(text,lineno))))\n\n        return nodes\n\n\nclass ProgramTransformer(ast.NodeTransformer):\n\n    def __init__(self,traceName,tracked,variables,expressions, exclusions, excludedFuncs, excludedLibs, extractedCalls, extractedComprehensions, source):\n        #init vars\n        #create unique id that will be used to name our variables in the transformed program\n        self.id = \"f\" + str(uuid.uuid4().hex)\n        self.traceName=  traceName\n        self.helper = TranfsormerHelpers(variables,expressions, exclusions,self,excludedFuncs,excludedLibs,source,extractedCalls, extractedComprehensions)\n        self.tracked = tracked\n        self.functionStack = []\n        self.extractedCalls = extractedCalls\n        self.extractedComprehensions = extractedComprehensions\n        self.source = source\n        self.exclLibs = excludedLibs\n\n    def visit_Import(self, node):\n        # print(\"IMPORTING\")\n        # print(\"EXCLIBS\", self.exclLibs)\n        names = node.names\n        for name in names:\n            if type(name) is ast.alias:\n                if name.name == \"numpy\" and name.asname is not None:\n                    self.numpyName = name.asname\n\n                    if \"numpy\" in self.exclLibs:\n                        self.exclLibs[self.exclLibs.index(\"numpy\")] = self.numpyName\n                elif name.name == \"numpy\":\n                    self.numpyName = \"numpy\"\n\n                if name.name == \"math\" and name.asname is not None:\n                    if \"math\" in self.exclLibs:\n                        self.exclLibs[self.exclLibs.index(\"math\")] = name.asname\n\n        return node\n\n    def visit_Module(self,node):\n        #create imports and things needed for the beginning of the transformed program\n\n        #create node to open the trace file\n        f = open(\"transformedFileHeader.txt\",\"r\")\n        text = f.read()\n        f.close()\n        text = text.replace(\"REPLACE\",self.id)\n        text = text.replace(\"TRACE_NAME\", self.traceName)\n        body = self.helper.parse_code(text,0)\n\n        for n in node.body:\n            body= self.helper.wrap_node(n,body)\n\n        f = open(\"closeFile.txt\", \"r\")\n        text = f.read()\n        f.close()\n        text = text.replace(\"REPLACE\", self.id)\n        body = list(np.concatenate((body,self.helper.parse_code(text,0))))\n\n\n        f = open(\"exceptionEnd.txt\", \"r\")\n        exceptionText = f.read()\n        f.close()\n        exceptionText = exceptionText.replace(\"REPLACE\", self.id)\n\n        exceptNode= ast.ExceptHandler(type=None, name=None, body=self.helper.parse_code(exceptionText,0))\n\n        tryNode = ast.Try(body = body, handlers=[exceptNode],orelse=[],finalbody=[])\n        node.body =[tryNode]\n\n        return node\n\n    def visit_FunctionDef(self, node):\n\n        self.functionStack.append([node.name,[]])\n        body =  self.helper.generate_tab_nodes(node.lineno,True)\n        for arg in node.args.args:\n            # body = list(np.concatenate(body,self.helper.wrap_node(arg,node.lineno)))\n            body = self.helper.wrap_node(arg, body)\n\n        for n in node.body:\n            body = self.helper.wrap_node(n,body)\n\n        node.body = body\n        self.functionStack.pop(-1)\n\n        return node\n\n    def visit_For(self, node):\n        if len(self.functionStack) > 0:\n            self.functionStack[-1][1].append(\"for\")\n\n        targets = []\n        if type(node.target) is ast.Tuple:\n            recordAttrs = {}\n            for i,t in enumerate(node.target.elts):\n                name = t.id\n                recordAttrs.update({\"targetVal\"+str(i+1):self.id+\"toStr(\"+name+\")\"})\n                targets.append(t)\n        else:\n            name = node.target.id\n            recordAttrs = {\"targetVal\": self.id+\"toStr(\"+name+\")\"}\n            targets.append(node.target)\n\n\n        n = len(self.helper.loopCounterIDStack)\n        counterID = self.helper.loopCounterIDStack[n - 1]\n        recordAttrs.update({\"iteration\": counterID})\n        incNode = ast.AugAssign(target=ast.Name(id=counterID, ctx=ast.Store()), op=ast.Add(), value=ast.Num(n=1))\n        incNode.lineno = node.lineno\n\n        body = [incNode]\n        fStr = self.helper.create_containing_function_str()\n        comprehensionKeys = self.extractedComprehensions.keys()\n        if node.lineno in comprehensionKeys:\n            fStr = fStr[:fStr.rfind(\"_\")]\n\n\n\n        for t in targets:\n            additionalAttrs = {}\n            tName = t.id\n            if tName  in self.helper.variables:\n                print(\"FOUND \", tName)\n                additionalAttrs.update(recordAttrs)\n                nTracked = len(self.tracked)\n                i = 0\n                obj = self.tracked[i]\n                while i < nTracked - 1 and (obj.name != tName or obj.containingFunc != fStr):\n                    i += 1\n                    obj = self.tracked[i]\n\n\n\n\n                if obj.containingFunc == fStr:\n                    lineInd = 0\n                    if node.lineno in comprehensionKeys:\n                        lines = self.helper.build_code_line(self.source[node.lineno-1:])\n                        print(lines)\n                        lines = lines.split(\"\\n\")\n                        while lineInd < len(lines) and lines[lineInd].find(\" for \") == -1:\n                            print(lines[lineInd])\n                            lineInd +=1\n\n                        line = self.source[node.lineno-1+lineInd]\n\n                        forInd = line.find(\" for \") + len(\" for \")\n                        inInd = line.find(\" in \")\n                        vs = line[forInd:inInd].split(\",\")\n                        offset = forInd\n\n                        for v in vs:\n\n                            if v.strip() == tName:\n                                offset += v.find(v.strip())\n                                self.helper.instances[tName].append([node.lineno+lineInd, offset])\n                                break\n                            else:\n                                offset += len(v) +1\n                    else:\n                        self.helper.instances[tName].append([node.lineno, t.col_offset])\n\n                    targetLbl = tName.replace(\"\\\"\", \"\\\\\\\"\")\n\n                    additionalAttrs.update({\"name\": \"\\\"\" + str(targetLbl) + \"\\\"\"})\n                    additionalAttrs.update({targetLbl: tName})\n                    if obj.custom is not None and len(obj.custom) > 0:\n                        for i, e in enumerate(obj.custom):\n                            f = open(\"custom.txt\", \"r\")\n                            text = f.read()\n                            f.close()\n                            text = text.replace(\"REPLACE_I\", str(i))\n                            text = text.replace(\"EXPR\", e)\n                            nodes = self.helper.parse_code(text, node.lineno)\n                            body = np.concatenate((body, nodes))\n                            additionalAttrs.update({e.replace(\"\\\"\", \"\\\\\\\\\\\\\\\"\"): \"cExp\" + str(i)})\n                    if node.lineno in comprehensionKeys:\n                        body = list(np.concatenate(\n                            (body, self.helper.create_opening_nodes(\"assign\", node.lineno + lineInd, additionalAttrs, body=False,\n                                                                    globals=False))))\n                        body = list(\n                            np.concatenate((body, self.helper.create_closing_nodes(\"assign\", node.lineno+lineInd, False))))\n                    else:\n                        body = list(np.concatenate(\n                        (body, self.helper.create_opening_nodes(\"assign\", node.lineno, additionalAttrs, body=False, globals=False))))\n                        body = list(np.concatenate((body, self.helper.create_closing_nodes(\"assign\", node.lineno, False))))\n\n        if node.lineno == 167:\n            print(ast.dump(node))\n            print(ast.dump(targets[0]))\n            print(ast.dump(targets[1]))\n\n        for n in node.body:\n            # print(ast.dump(n))\n            body = self.helper.wrap_node(n,body,recordAttrs)\n\n        node.body = body\n\n        if len(self.functionStack) > 0:\n            self.functionStack[-1][1].pop(-1)\n\n        return node\n\n\n\n\n    def visit_While(self, node):\n        if len(self.functionStack) > 0:\n            self.functionStack[-1][1].append(\"while\")\n\n        self.visit(node.test)\n        n = len(self.helper.loopCounterIDStack)\n        counterID = self.helper.loopCounterIDStack[n-1]\n        recordAttrs = {\"iteration\":counterID}\n        body = []\n\n        for n in node.body:\n            body = self.helper.wrap_node(n,body,recordAttrs)\n\n        incNode = ast.AugAssign(target = ast.Name(id=counterID, ctx=ast.Store()), op=ast.Add(), value = ast.Num(n=1))\n        incNode.lineno = node.lineno\n        body.append(incNode)\n\n        node.body = body\n\n        if len(self.functionStack) > 0:\n            self.functionStack[-1][1].pop(-1)\n\n        return node\n\n    def visit_With(self,node):\n\n        body = []\n        for n in node.body:\n            body = self.helper.wrap_node(n, body, {})\n\n        node.body = body\n\n        return node\n\n\nclass CallTransformer(ast.NodeTransformer):\n    def __init__(self,source,tracked):\n        self.source = source\n        self.tracked = tracked\n        self.extractedCalls = {}\n        self.expandedComprehensions = {}\n\n    def visit_If(self,node):\n        body = []\n        for n in node.body:\n            self.extractCalls(n,body, True)\n            n =self.visit(n)\n            body.append(n)\n        elseBody = []\n        for n in node.orelse:\n            self.extractCalls(n,elseBody, True)\n            n = self.visit(n)\n            elseBody.append(n)\n        node.body = body\n        node.orelse = elseBody\n        return node\n\n    def visit_For(self,node):\n        body = []\n        for n in node.body:\n            self.extractCalls(n,body,True)\n            n =self.visit(n)\n            body.append(n)\n        node.body = body\n        return node\n\n    def visit_While(self,node):\n        body = []\n        for n in node.body:\n            self.extractCalls(n, body, True)\n            n = self.visit(n)\n            body.append(n)\n        node.body = body\n        return node\n\n    def visit_FunctionDef(self,node):\n        body = []\n        for n in node.body:\n            self.extractCalls(n, body, True)\n            n = self.visit(n)\n            body.append(n)\n        node.body = body\n        return node\n\n    def visit_Module(self,node):\n        if hasattr(node,\"body\"):\n            body = []\n            for n in node.body:\n                self.extractCalls(n, body, True)\n                n = self.visit(n)\n                body.append(n)\n            node.body = body\n        return node\n\n\n\n\n    def extractCalls(self, node, body, ignoreCall = False):\n        nodeType = type(node)\n\n        if nodeType is ast.Assign or nodeType is ast.AugAssign:\n            n = self.extractCalls(node.value, body)\n            n.lineno = node.lineno\n\n            node.value = n\n\n\n            return node\n\n        elif nodeType is ast.BinOp:\n            left = self.extractCalls(node.left,body)\n            right = self.extractCalls(node.right,body)\n            node.left = left\n            node.right = right\n            return node\n\n        elif nodeType is ast.Return or nodeType is ast.Yield:\n            if node.value is not None:\n                n = self.extractCalls(node.value, body)\n                n.lineno = node.lineno\n                node.value = n\n            return node\n\n        elif nodeType is ast.Tuple:\n            for i, elt in enumerate(node.elts):\n                n = self.extractCalls(elt,body)\n                n.lineno = node.lineno\n                node.elts[i] = n\n            return node\n\n        elif nodeType is ast.Expr:\n            if type(node.value) is ast.Call:\n                n = self.extractCalls(node.value,body, ignoreCall)\n                n.lineno = node.lineno\n                node.value = n\n\n            elif type(node.value) is ast.ListComp:\n                n = self.extractCalls(node.value,body)\n                n.lineno = node.lineno\n                node.value = n\n\n            elif type(node.value) is ast.Yield:\n                n = self.extractCalls(node.value, body)\n                n.lineno = node.lineno\n                node.value = n\n            return node\n        elif nodeType is ast.ListComp:\n            f = open(\"listCompToFor.txt\")\n            # f = open(\"helperText/listCompToFor.txt\")\n\n            text = f.read()\n            f.close()\n            lines = text.split(\"\\n\")\n            generator = node.generators[0]\n\n            targets = astor.to_source(generator.target).strip()\n            body2 = []\n            expr = self.extractCalls(node.elt,body2)\n            yieldExpr = astor.to_source(expr)\n            rangeN = self.extractCalls(generator.iter, body)\n            forRange = astor.to_source(rangeN).strip()\n            origline = self.source[node.lineno - 1]\n\n            if len(generator.ifs) >0:\n                ifN = self.extractCalls(generator.ifs[0],body2)\n                ifTest =  astor.to_source(ifN).strip()\n                ifInd = origline.find(\"if\")\n            else:\n                ifTest = \"\"\n                ifInd = -1\n\n            text = text.replace(\"REPLACEEXPR\", yieldExpr)\n            text = text.replace(\"REPLACEV\",targets)\n\n            text = text.replace(\"REPLACERANGE\", forRange)\n\n            if (len(generator.ifs) > 0):\n                text = text.replace(\"REPLACEIF\", ifTest)\n            else:\n                text = text.replace(\"REPLACEIF\", \"True\")\n\n            fname = \"f\" + str(uuid.uuid4().hex) + \"gen\"\n\n            text = text.replace(\"REPLACEFUNC\", fname)\n\n            n= ast.parse(text).body[0]\n            n.lineno = node.lineno\n            #set lineno of for loop\n            n.body[0].lineno = node.lineno\n            #set lineno of if\n            n.body[0].body[0].lineno = node.lineno\n            #set lineno of if body and add body2 to it\n            n.body[0].body[0].body = np.concatenate((body2, n.body[0].body[0].body))\n            for n2 in n.body[0].body[0].body:\n                n2.lineno = node.lineno\n\n\n            self.expandedComprehensions.update({node.lineno:{\"func\":text,\"targetInd\": node.col_offset + lines[1].find(\"REPLACEV\"), \"yieldExprInd\":node.col_offset + lines[-1].find(\"REPLACEEXPR\"), \"ifTestInd\":lines[-1].find(\"REPLACEIF\"), \"origLine\":origline}})\n            # n = self.visit(n)\n            body.append(n)\n\n            return ast.parse(\"list(\" + fname + \"())\").body[0].value\n\n\n        elif nodeType is ast.Call:\n            for i,arg in enumerate(node.args):\n                n = self.extractCalls(arg,body)\n                n.lineno = arg.lineno\n\n                node.args[i] = n\n\n            if not ignoreCall:\n                id = \"v\"+str(uuid.uuid4().hex)\n                n = ast.Assign([ast.Name(id,ast.Store())],node)\n                n.lineno = node.lineno\n                #the start of the original call\n                startInd = node.col_offset\n                openParenthCt = 1\n                curLine = n.lineno - 1\n                #get the portion of the line containing the orignal function\n                line = self.source[curLine][startInd:]\n\n                ind = line.find(\"(\") + 1\n\n\n                #search for the closing parentheses of the call, keeping track of all parentheses in case of nested calls\n                while openParenthCt > 0:\n                    if ind == len(line) and openParenthCt > 0:\n                        curLine += 1\n                        line = self.source[curLine]\n                        ind = 0\n                    if line[ind] == \"(\":\n                        openParenthCt += 1\n                    elif line[ind] == \")\":\n                        openParenthCt -= 1\n                    ind += 1\n\n\n\n                #check if the call is fully contained on a single line\n                if curLine == n.lineno-1 or (curLine == n.lineno and ind == 0):\n                    callExpr = self.source[n.lineno-1][startInd:ind+startInd]\n                else:\n                    #if not, set the expression to the first line\n                    callExpr = self.source[n.lineno-1][startInd:]\n                #add each additional line except the last (if the call spans multiple lines)\n                for i in range(n.lineno,curLine-1):\n                    callExpr += self.source[i]+\"\\n\"\n                #Add the last line if it spans multiple lines\n                if curLine != n.lineno-1:\n                    callExpr += self.source[curLine][:ind]\n                #check if the line already exists in the call infos\n                if n.lineno in self.extractedCalls.keys():\n                    #add offset and variable expression pair to the calls\n                    self.extractedCalls[n.lineno].update({node.col_offset: [id, callExpr]})\n                else:\n                    #add the line, the offset, and the variable expression pair to the calls\n                    self.extractedCalls.update({n.lineno: {node.col_offset: [id, callExpr]}})\n                body.append(n)\n\n\n\n                return ast.Name(id,ast.Load())\n            else:\n                return node\n\n        else:\n            return node\n\ndef createInfo(lineno):\n    info={\"start\":lineno,\n          \"end\":None}\n    return  info\n\ndef sv_generateHead(source):\n    return ast.parse(source)\n\n\ndef build_code_line(lines):\n\n    ind = 0\n    curLine = lines[ind].strip()\n    whitespace = lines[ind][:lines[ind].find(lines[ind].strip())]\n    blockStack = []\n    lineInd = 0\n    inString = False\n    curQuote = None\n    lineText = whitespace + lines[ind].strip()\n    # print(curLine)\n    while (lineInd < len(curLine) or len(blockStack) > 0):\n\n        if curLine[lineInd] == \"\\\"\" or curLine[lineInd] == \"'\":\n            if inString and curLine[lineInd] == curQuote:\n                curQuote = None\n                inString = False\n            elif not inString:\n                inString = True\n                curQuote = curLine[lineInd]\n\n        if not inString:\n            if curLine[lineInd] == \"[\" or curLine[lineInd] == \"(\" or curLine[lineInd] == \"{\":\n                blockStack.append(curLine[lineInd])\n            elif curLine[lineInd] == \"]\" or curLine[lineInd] == \")\" or curLine[lineInd] == \"}\":\n                blockStack.pop()\n        lineInd += 1\n\n        if lineInd == len(curLine) and len(blockStack) > 0:\n            ind += 1\n            whitespace = lines[ind][:lines[ind].find(lines[ind].strip())]\n            curLine = lines[ind].strip()\n            lineText += \"\\n\"+whitespace + curLine\n            lineInd = 0\n\n    return lineText\n\nclass CallExtentVisitor(ast.NodeVisitor):\n    def __init__(self,source):\n        self.functions = {}\n        self.loops = {}\n        self.source = source\n\n    def visit(self,node):\n        nodeType = type(node)\n        if nodeType is ast.While:\n            info = createInfo(node.lineno)\n\n            endNode = self.get_last_child(node.body)\n\n            info[\"end\"] = endNode.lineno\n\n            self.loops.update({\"while-\" + str(node.lineno): info})\n        elif nodeType is ast.For:\n            info = createInfo(node.lineno)\n            endNode = self.get_last_child(node.body)\n\n            info[\"end\"] = endNode.lineno\n\n            self.loops.update({\"for-\" + str(node.lineno): info})\n        elif nodeType is ast.FunctionDef:\n            info = createInfo(node.lineno)\n            endNode = self.get_last_child(node.body)\n\n            info[\"end\"] = endNode.lineno\n\n            self.functions.update({node.name: info})\n        elif nodeType is ast.Assign and type(node.value)is ast.ListComp:\n            info = createInfo(node.value.lineno)\n            # endNode = self.get_last_child(node.body)\n\n            lines = build_code_line(self.source[node.value.lineno - 1:])\n            lines = lines.split(\"\\n\")\n\n            info[\"end\"] = node.value.lineno + len(lines)-1\n\n            self.loops.update({\"for-\" + str(node.lineno): info})\n\n        if hasattr(node,\"body\"):\n            for n in node.body:\n                self.visit(n)\n\n\n\n    def get_last_child(self,body):\n        lastNode = body[-1]\n        while hasattr(lastNode,\"body\"):\n            if type(lastNode) is ast.If and hasattr(lastNode,\"orelse\") and len(lastNode.orelse) >0:\n                lastNode = lastNode.orelse[-1]\n            else:\n                lastNode = lastNode.body[-1]\n\n        return lastNode\n\n\n\n    def visit_While(self,node):\n        for n in node.body:\n            self.visit(n)\n            print(ast.dump(n))\n\n        info = createInfo(node.lineno)\n\n        endNode = self.get_last_child(node.body)\n\n        info[\"end\"] =endNode.lineno\n\n        self.loops.update({\"while-\"+str(node.lineno):info})\n\n    def visit_For(self, node):\n        for n in node.body:\n            self.visit(n)\n            print(ast.dump(n))\n\n        info = createInfo(node.lineno)\n        endNode = self.get_last_child(node.body)\n\n        info[\"end\"] = endNode.lineno\n\n        self.loops.update({\"for-\"+str(node.lineno):info})\n\n\n    def visit_Expr(self,node):\n        print(ast.dump(node))\n        if type(node.value) is ast.ListComp:\n            print(\"HERE\")\n            info = createInfo(node.value.lineno)\n            # endNode = self.get_last_child(node.body)\n\n            lines = build_code_line(self.source[node.value.lineno-1:])\n            lines = lines.split(\"\\n\")\n\n\n            info[\"end\"] =node.line + len(lines)\n\n            self.loops.update({\"for-\" + str(node.lineno): info})\n\n    def visit_FunctionDef(self,node):\n        for n in node.body:\n            self.visit(n)\n\n        info = createInfo(node.lineno)\n        endNode = self.get_last_child(node.body)\n\n        info[\"end\"] = endNode.lineno\n\n        self.functions.update({node.name: info})\n\n\nclass DependencyVisitor(ast.NodeVisitor):\n    def __init__(self):\n        self.contributors = {}\n        self.functionStack =[]\n\n    def visit_FunctionDef(self, node):\n        self.functionStack.append(node.name)\n        for n in node.body:\n            self.visit(n)\n        self.functionStack.pop(-1)\n\n    def visit_Assign(self, node):\n        targets = node.targets\n        val = node.value\n\n        if len(self.functionStack) > 0:\n            func = self.functionStack[-1]\n        else:\n            func = \"\"\n\n        keys = []\n        dependencies = []\n        targType = type(targets[0])\n\n        if targType is ast.Tuple:\n            elements = targets[0].elts\n            if type(val) is ast.Tuple:\n                valElts = val.elts\n                for i in range(len(elements)):\n                    dep = self.parse_expr(valElts[i])\n\n                    if type(elements[i]) is ast.Name:\n                        keys.append(func + \"_\" + elements[i].id)\n                        dependencies.append(dep)\n                    else:\n                        # print(\"UNHANDLED ASSIGNMENT: \", ast.dump(node))\n                        pass\n            elif type(val) is ast.Call:\n                dep = self.parse_expr(val)\n                for i in range(len(elements)):\n                    keys.append(func + \"_\" + elements[i].id)\n                    dependencies.append(dep)\n\n        elif type(targets[0]) is ast.Name:\n            deps = self.parse_expr(val)\n            keys.append(func + \"_\" + targets[0].id)\n            dependencies.append(deps)\n            # self.contributors.update({func + \"_\" + targets[0].id: deps})\n        else:\n            # print(\"UNHANDLED ASSIGNMENT: \", ast.dump(node))\n            pass\n        for i, keyname in enumerate(keys):\n            if keyname in self.contributors:\n                for d in dependencies[i]:\n                    self.contributors[keyname].append(d)\n            else:\n                self.contributors.update({keyname: dependencies[i]})\n\n    def visit_AugAssign(self, node):\n        target = node.target\n        val = node.value\n        if len(self.functionStack) > 0:\n            func = self.functionStack[len(self.functionStack) - 1]\n        else:\n            func = \"\"\n\n        keyname = None\n        dependencies = []\n        if type(target) is ast.Name:\n\n            deps = self.parse_expr(val)\n\n            keyname = func + \"_\" + target.id\n            dependencies = deps\n            dependencies.append(keyname)\n        else:\n            # print(\"UNHANDLED ASSIGNMENT: \", ast.dump(node))\n            pass\n\n        if keyname is not None:\n            if keyname in self.contributors:\n                for d in dependencies:\n                    self.contributors[keyname].append(d)\n            else:\n                self.contributors.update({keyname: dependencies})\n\n    def visit_Return(self, node):\n\n        if len(self.functionStack) > 0:\n            func = self.functionStack[len(self.functionStack) - 1]\n        else:\n            func = \"\"\n\n        name = func + \"_return\"\n        if node.value is not None:\n            dependencies = self.parse_expr(node.value)\n            self.contributors.update({name: dependencies})\n\n    def parse_expr(self, expr):\n        depends = []\n        if len(self.functionStack) > 0:\n            func = self.functionStack[- 1]\n        else:\n            func = \"\"\n        if type(expr) is ast.BinOp:\n            ldeps = self.parse_expr(expr.left)\n            rdeps = self.parse_expr(expr.right)\n            for d in ldeps:\n                depends.append(d)\n            for d in rdeps:\n                depends.append(d)\n        elif type(expr) is ast.Tuple:\n            elts = expr.elts\n            for e in elts:\n                deps = self.parse_expr(e)\n                for d in deps:\n                    depends.append(d)\n\n        elif type(expr) is ast.Name:\n            depends.append(func + \"_\" + expr.id)\n        elif type(expr) is ast.Call:\n\n            if type(expr.func) is ast.Name:\n                name = expr.func.id + str(expr.lineno)\n\n            elif type(expr.func) is ast.Attribute:\n\n                dep = self.parse_expr(expr.func.value)\n\n                if len(dep) > 0:\n                    ind = dep[0].find(func + \"_\")\n\n                    if ind > -1 and ind < len(func) + 1:\n                        dep[0] = dep[0].replace(func + \"_\", \"\")\n                    name = dep[0] + \".\" + expr.func.attr + str(expr.lineno)\n                else:\n                    name = \"\"\n\n            else:\n                # print(\"UNHANDLED CALL: \", ast.dump(expr.func))\n                # print(\"BROKE WITH LAMBDAS\")\n                name = \"\"\n            args = expr.args\n\n            depends.append(name)\n            deps2 = []\n            for arg in args:\n                dep = self.parse_expr(arg)\n                for d in dep:\n                    deps2.append(d)\n\n            if name in self.contributors:\n                for d in deps2:\n                    self.contributors[name].append(d)\n            else:\n                self.contributors.update({name: deps2})\n\n        elif type(expr) is ast.Num:\n            pass\n        elif type(expr) is ast.Attribute:\n            dep = self.parse_expr(expr.value)\n            depends.append(dep[0] + \".\" + expr.attr)\n        elif type(expr) is ast.Str:\n            pass\n            # Nothing needs to happen for hardcoded strings, no dependencies there\n        elif type(expr) is ast.Subscript:\n            # build subscript expression, make all indices dependencies\n            name = \"\"\n            curExpr = expr\n\n            while type(curExpr.value) is ast.Subscript:\n                n = \"[\"\n                if type(curExpr.slice.value) is ast.Name:\n                    n += curExpr.slice.value.id\n                elif type(curExpr.slice.value) is ast.Num:\n                    n += str(curExpr.slice.value.n)\n                elif type(curExpr.slice.value) is ast.Str:\n                    n += curExpr.slice.value.s\n                else:\n                    # print(\"UNHANDLED INDEX TYPE\")\n                    pass\n                n += \"]\"\n                name = n + name\n                curExpr = curExpr.value\n\n            depends.append(func + \"_\" + name)\n        else:\n            # print(\"UNHANDLED: \", ast.dump(expr))\n            pass\n        return depends\n\n\nclass Tracer:\n    def __init__(self):\n        self.tracked =[]\n        self.variables = []\n        self.expressionLines = []\n        self.exclusions = []\n        self.excludedFuncs = []\n        self.excludedLibs = []\n\n    def readFile(self,filename):\n        self.filename = filename\n        f = open(filename,'r')\n        text =f.read()\n        self.text =text\n        return text\n\n    def runTrace(self, filePrefix = None):\n        if filePrefix is None:\n            filePrefix = self.filename.replace(\".py\", \"\")\n            date = str(datetime.datetime.fromtimestamp(time.time())).replace(\" \", \"_\")\n            filePrefix += date.split(\".\")[0]\n\n        trimmedFname = filePrefix\n        filePrefix = filePrefix.replace(\"\\\\\", \"/\")\n        # print(filePrefix)\n\n        tObjs = self.tracked.copy()\n\n        self.lines = self.text.split(\"\\n\")\n        node = ast.parse(self.text)\n\n        transf = CallTransformer(self.lines,self.tracked)\n        node = transf.visit(node)\n        self.extractedCalls = transf.extractedCalls\n        self.extractedComprehensions = transf.expandedComprehensions\n        self.head = node\n\n\n        self.transformer = ProgramTransformer(filePrefix+\".trace\",tObjs, self.variables,\n                                   self.expressionLines, self.exclusions, self.excludedFuncs, self.excludedLibs,\n                                                          self.extractedCalls,self.extractedComprehensions, self.lines)\n\n\n        ind = trimmedFname.find(\"/\")\n        while(ind >= 0):\n            trimmedFname = trimmedFname[ind+1:]\n            fs = trimmedFname.find(\"/\")\n            bs = trimmedFname.find(\"\\\\\")\n            if fs > bs:\n                ind = fs\n            else:\n                ind = bs\n\n\n\n        outputs = self.transformer.visit(self.head)\n\n        ast.fix_missing_locations(outputs)\n\n        f = open(\"alteredCodeTest.py\", \"w\")\n\n        f.write(astor.to_source(outputs))\n        f.close()\n\n        old_dir = os.getcwd()\n        print(\"OLD DIR: \", old_dir)\n        global source\n        source = astor.to_source(outputs)\n\n        # div = js.document.getElementById(\"newSrc\")\n        # div.innerHTML = source\n        # print(div)\n\n\n        comp = compile(outputs, trimmedFname, mode='exec')\n\n        d = {}\n        d['__name__'] = '__main__'\n\n        dir_path = os.path.dirname(os.path.realpath(self.filename))\n        print(\"dir_path: \", dir_path)\n\n        sys.argv = [dir_path+\"/\"+trimmedFname+\".py\"]\n\n        old_stdout = sys.stdout\n        sys.stdout = StringIO()\n\n        exec(comp, d, d)\n        self.output = sys.stdout.getvalue()\n        os.chdir(old_dir)\n        sys.stdout = old_stdout\n        print(self.output)\n        self.cleanJson(self.transformer)\n        print(\"all clean\")\n\n        return source\n\n    def cleanJson(self, transf):\n\n        f = open(transf.traceName, \"r\")\n        text = f.read()\n        text = text.replace(\"},\\nDELETE\", \"}\")\n        text = text.replace(\",\\nDELETE\", \"\")\n        text = text.replace(\"DELETE\\n\", \"\")\n        text = text.replace(\"DELETE\", \"\")\n        f.close()\n\n        f = open(transf.traceName, \"w\")\n        i = len(text) - 1\n        token = text[i]\n        while token != \"}\":\n            i -= 1\n            token = text[i]\n        text = text[:i]\n\n        text += \",\\n\"\n        f.write(text)\n\n        f.write(\"\\t\\\"tracked\\\":[\\n\")\n        n = len(self.tracked)\n        i = 0\n        for obj in self.tracked:\n            s = \"\\t\\t{\\\"name\\\":\\\"\" + str(obj.name) +\"\\\"\"\n            if obj.var:\n                s += \",\\\"instances\\\":[\"\n                print(transf.helper.instances[obj.name])\n                for inst in transf.helper.instances[obj.name]:\n                    s += \"{\\\"lineno\\\":\" + str(inst[0]) + \", \\\"offset\\\":\" + str(inst[1]) + \"},\"\n                s = s[:-1]\n                s += \"]\"\n\n            else:\n                s +=\",\\\"instances\\\":[{\\\"lineno\\\":\" + str(obj.lineno) + \", \\\"offset\\\":\" + str(obj.offset) + \"}]\"\n            s += \",\\n\\t\\t\\\"custom\\\":[\"\n\n            if obj.custom is not None and len(obj.custom)>0:\n                for e in obj.custom:\n                    s+=\"\\\"\" +e.replace(\"\\\"\",\"\\\\\\\"\") + \"\\\",\"\n                s = s[:-1]\n            s+=\"]\"\n            s += \"}\"\n\n            f.write(s)\n            if i < n - 1:\n                f.write(\",\\n\")\n            else:\n                f.write(\"\\n\")\n            i += 1\n        f.write(\"\\t]\\n}\\n\")\n\n        f.close()\n\n\n    def add_tracked(self,trackedObj):\n        self.tracked.append(trackedObj)\n        if trackedObj.var:\n            self.variables.append(trackedObj.name)\n        else:\n            self.expressionLines.append(trackedObj.lineno)\n\n    # def remove_tracked(self,trackedObj):\n\n    def add_exclusion(self,exclusion):\n        self.exclusions.append(exclusion)\n        if exclusion.func:\n            self.excludedFuncs.append(exclusion.name)\n        else:\n            self.excludedLibs.append(exclusion.name)\n\n\nvariables = None\ntracked = []\n\ndef initialize_tracer(fname):\n    t = Tracer()\n\n    lines = t.readFile(fname)\n    return t, lines\n\n\ndef addObject(tracer, name, isVar, lineno, offset, containingFuncStr,custom):\n    obj = TrackObject(name, isVar, lineno, offset, containingFuncStr,custom)\n    tracked.append(obj)\n    tracer.add_tracked(obj)\n\n\ndef findContainingFuncs(lineno,functions):\n    funcs = list(functions.keys())\n    ind = 0\n    maxInd = len(funcs)\n    currChoice = \"\"\n    for i in range(maxInd):\n        if (functions[funcs[i]][\"start\"] < lineno and functions[funcs[i]][\"end\"] >= lineno):\n            if currChoice == \"\":\n                currChoice = funcs[i]\n            else:\n                if functions[funcs[currChoice]][\"start\"] < functions[funcs[i]][\"start\"] and functions[funcs[currChoice]][\"end\"] >= functions[funcs[i]][\"end\"]:\n                        currChoice = currChoice+\"_\"+funcs[i]\n\n    return currChoice\n\n\ndef addExclusion(tracer, name, isFunc, lineno, containingFuncStr):\n    obj = ExclusionObject(name, isFunc, lineno, containingFuncStr)\n    tracer.add_exclusion(obj)\n\n\ndef runTrace(fname, variables, expressions, funcExclusions, libExclusions, overview, outputFileName=None):\n    import os\n    print(\"CWD: \", os.getcwd())\n\n    f = open(fname, \"r\")\n    text = f.read()\n    f.close()\n    head = sv_generateHead(text)\n\n    visitor = CallExtentVisitor(text.split(\"\\n\"))\n    visitor.visit(head)\n    functions = visitor.functions\n    loops = visitor.loops\n\n    visitor = DependencyVisitor()\n    visitor.visit(head)\n    dependencies = visitor.contributors\n    # print(dependencies)\n\n    # visitor = staticVisitor.JoinVisitor()\n    # visitor.visit(head)\n\n\n    t, lines = initialize_tracer(\"./\" + fname)\n\n    for v in variables:\n        funcStr = findContainingFuncs(v[\"line\"], functions)\n        print(v, funcStr)\n        addObject(t, v[\"name\"], True, v[\"line\"], v[\"offset\"], funcStr, v[\"custom_exprs\"])\n\n    for e in expressions:\n        funcStr = findContainingFuncs(e[\"line\"], functions)\n\n        addObject(t, e[\"expr\"], False, e[\"line\"], e[\"offset\"], funcStr, e[\"custom_exprs\"])\n\n    for f in funcExclusions:\n        if f[\"name\"] in functions:\n            contStr = findContainingFuncs(functions[f[\"name\"]][\"start\"]+1, functions)\n\n            if contStr != \"\":\n                contStr = contStr[:contStr.find(f[\"name\"])]\n        else:\n            contStr = \"\"\n        addExclusion(t, f[\"name\"], True, f[\"line\"], contStr)\n\n\n\n    for f in libExclusions:\n        if f[\"name\"] in functions:\n            contStr = findContainingFuncs(functions[f[\"name\"]][\"start\"]+1, functions)\n            contStr = contStr[:contStr.find(f[\"name\"])]\n        else:\n            contStr = \"\"\n        addExclusion(t, f[\"name\"], False, f[\"line\"], contStr)\n\n    t.readFile(fname)\n    source = t.runTrace(outputFileName)\n    output = t.output\n    lines = output.split(\"\\n\")\n    output = \"\"\n    for line in lines:\n        output += line+\"\\\\n\"\n\n    return outputFileName + \".trace\", functions, dependencies, output, loops\n    # return t,source\n\n#     t, source = runTrace(\"testProg.py\", [{\"line\":6,\"name\":\"output\", \"offset\":8, \"custom_exprs\":None}], [],[],[], None, \"test_trace\")\n#\n# do_work()\n"
